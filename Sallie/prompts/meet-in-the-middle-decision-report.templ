INPUT 1: SOURCE CODE

@@INPUT1@@

INPUT 2: BUSINESS LOGIC

@@INPUT_FILE_CONTENT@@

INPUT 3: SUGGESTED HIERARCHIES

@@INPUT_FILE2_CONTENT@@  

INSTRUCTIONS

Take a look at the suggested decision hierarchies (input 3) - which describes how to organise the existing top-level decisions and base decisions in input 2, which are missing the middle layer that bind them together. 

You must return a json that includes:

1. A new set of composite decisions in the middle layer, with links that go base (output/source) -> (input/target) composite (output/source) -> (input/target) top-level (note that links physically reside as a property on the target decisions).
1.1 Pay careful attention to the direction of decision flows in your hierarchy, starting from base decision and BKMs at the bottom, flowing into composite decisions in the middle, flowing into top-level decisions on top.
1.2 Make sure the new middle-layer decisions doesn't implement the same logic in the existing base decisions, but rather takes outputs from the base layer and matching exactly to inputs. It is critical that the base outputs map to the middle composite inputs exactly, so formulate the inputs of the middle-layer to be an exact match for the output of the base layer.
1.3 Make sure the new middle-layer decisions doesn't implement the same logic as the existing top-level decisions, but provides outputs that match their inputs. It is critical that the middle ouputs map to the top-level inputs exactly, so formulate the outputs of the middle-layer to be an exact match for the inputs of the top layer.
1.4 Use blanks for the following json fields: rule_id, rule_category, ai_categorised, component, owner, category_explanation. Also set the kind to Decision (Composite) for these new decisions.
1.5 It is very important that you set rule_id to "" for a new composite decision, do not try and come up with some value.
1.5 This may involve generating one, multiple, or no middle-layer composite decisions. If none, just return an empty json.

2. Existing top-level decisions, with new links added to their links property that show the new links coming from the composite decisions. 
2.1 Where you see a top-level decision with an empty rule_id (i.e. "") it will need to be created. To indicate that you need to include it in the output with an empty rule_id i.e. "", setting its kind to Decision (Top-Level) and giving it a suitable purpose, spec, example, and inputs and outputs, and incoming links.

3. Any other existing decisions for which you need to add missing links to properly reflect the suggested hierarchy in input 3 (with new links added to their links property).

Be careful when creating links, they need to adhere to these rules:

- Decisions should flow up to the top-level. Links should go from base decision/BKMs, to composite decisions, to top-level decisions (but links physically reside in the links property on the target decision)
- Only top-level and composite decisions should have links properties (containing the links coming into them). 
- DO NOT create loops where a decision links to a another decision that then links back to the original.
- ONLY create the link on the decision that is the target (it is implied on the source).
- Ensure that all lower decisions in a hierarchy flow up to a composite decision.
- Ensure that there are no decisions at any level that have a top-level decision in its links property (this is because top-level links can't be a source).

Reponse must be in this json structure:

[
{
"rule_name": "Persist Operation Result",
"rule_purpose": "Map a database save outcome into a normalized operation result and optional error message",
"rule_spec": "If Database.SaveResult.isSuccess is true set OperationResult to success and ErrorMessage to dash. Otherwise set OperationResult to error and copy Database.SaveResult.errors into ErrorMessage",
"code_block": "",
"code_file": "",
"code_lines": [],
"code_function": "",
"example": "Save fails with validation error results in OperationResult error and ErrorMessage containing the validation text",
"dmn_hit_policy": "UNIQUE",
"dmn_inputs": [
{ "name": "Database.SaveResult.isSuccess", "type": "boolean" },
{ "name": "Database.SaveResult.errors", "type": "string" }
],
"dmn_outputs": [
{ "name": "OperationResult", "type": "string", "allowedValues": ["success", "error"] },
{ "name": "ErrorMessage", "type": "string" }
],
"dmn_table": "| Database.SaveResult.isSuccess condition | OperationResult | ErrorMessage |\n|––––––––––––––––––––|—————–|–––––––|\n| true                                   | success         | -            |\n| false                                  | error           | Database.SaveResult.errors |",
"timestamp": "2025-11-07T00:10:00.000Z",
"id": "base-ops-result-001",
"owner": "SF Team",
"component": "SF Code",
"kind": "Decision",
"links": [],
"doc_rule_id": null,
"rule_category": "Audit",
"business_area": null,
"doc_match_score": 0,
"ai_categorized": true,
"category_explanation": "Normalizes DB outcomes for audit and downstream decisions",
"archived": false
},
{
"rule_name": "Should Error Email Be Sent",
"rule_purpose": "Determine whether to send an error notification email based on the presence of errors in the batch",
"rule_spec": "If ErrorMap is not empty send email otherwise do not send",
"code_block": "",
"code_file": "",
"code_lines": [],
"code_function": "",
"example": "Three failed records produce SendEmail true",
"dmn_hit_policy": "UNIQUE",
"dmn_inputs": [
{ "name": "ErrorMap.isEmpty", "type": "boolean" }
],
"dmn_outputs": [
{ "name": "SendEmail", "type": "boolean" }
],
"dmn_table": "| ErrorMap.isEmpty condition | SendEmail |\n|—————————|———–|\n| false                     | true      |\n| true                      | false     |",
"timestamp": "2025-11-07T00:10:00.000Z",
"id": "base-send-email-001",
"owner": "SF Team",
"component": "SF Code",
"kind": "Decision",
"links": [],
"doc_rule_id": null,
"rule_category": "Audit",
"business_area": null,
"doc_match_score": 0,
"ai_categorized": true,
"category_explanation": "Controls error notification behavior",
"archived": false
},
{
"rule_name": "Compose Error Notification Outcome",
"rule_purpose": "Compose whether to notify and the message body by combining operation result and send email decision",
"rule_spec": "Send a notification only when SendEmail is true and OperationResult equals error. Set Notification.Body to ErrorMessage when sending otherwise dash",
"code_block": "",
"code_file": "",
"code_lines": [],
"code_function": "",
"example": "If SendEmail is true and OperationResult is error then Notification.ShouldSend is true and Notification.Body is the ErrorMessage",
"dmn_hit_policy": "FIRST",
"dmn_inputs": [
{ "name": "OperationResult", "type": "string", "allowedValues": ["success", "error"] },
{ "name": "ErrorMessage", "type": "string" },
{ "name": "SendEmail", "type": "boolean" }
],
"dmn_outputs": [
{ "name": "Notification.ShouldSend", "type": "boolean" },
{ "name": "Notification.Body", "type": "string" }
],
"dmn_table": "| SendEmail condition | OperationResult condition | Notification.ShouldSend | Notification.Body |\n|———————|—————————|———————––|—————––|\n| true                | "error"                   | true                    | ErrorMessage      |\n| -                   | -                         | false                   | -                 |",
"timestamp": "2025-11-07T00:10:00.000Z",
"id": "mid-compose-notify-001",
"owner": "",
"component": "",
"kind": "Decision (Composite)",
"links": [
{ "from_step": "Persist Operation Result", "from_output": "OperationResult", "to_input": "OperationResult", "kind": "depends_on" },
{ "from_step": "Persist Operation Result", "from_output": "ErrorMessage", "to_input": "ErrorMessage", "kind": "depends_on" },
{ "from_step": "Should Error Email Be Sent", "from_output": "SendEmail", "to_input": "SendEmail", "kind": "depends_on" }
],
"doc_rule_id": null,
"rule_category": "",
"business_area": null,
"doc_match_score": 0,
"ai_categorized": "",
"category_explanation": "",
"archived": false
},
{
"rule_name": "Execute Error Notification",
"rule_purpose": "Trigger the actual email send based on composed notification outcome",
"rule_spec": "If Notification.ShouldSend is true send an email using Notification.Body otherwise take no action",
"code_block": "",
"code_file": "",
"code_lines": [],
"code_function": "",
"example": "When Notification.ShouldSend is true an email is sent with the composed body",
"dmn_hit_policy": "UNIQUE",
"dmn_inputs": [
{ "name": "Notification.ShouldSend", "type": "boolean" },
{ "name": "Notification.Body", "type": "string" }
],
"dmn_outputs": [
{ "name": "Email.Sent", "type": "boolean" }
],
"dmn_table": "| Notification.ShouldSend condition | Email.Sent |\n|–––––––––––––––––|————|\n| true                             | true       |\n| false                            | false      |",
"timestamp": "2025-11-07T00:10:00.000Z",
"id": "top-execute-email-001",
"owner": "SF Team",
"component": "SF Code",
"kind": "Decision (Top-Level)",
"links": [
{ "from_step": "Compose Error Notification Outcome", "from_output": "Notification.ShouldSend", "to_input": "Notification.ShouldSend", "kind": "depends_on" },
{ "from_step": "Compose Error Notification Outcome", "from_output": "Notification.Body", "to_input": "Notification.Body", "kind": "depends_on" }
],
"doc_rule_id": null,
"rule_category": "Audit",
"business_area": null,
"doc_match_score": 0,
"ai_categorized": true,
"category_explanation": "Top level trigger based on composed outcome",
"archived": false
}
]

Hints
* Respond as if you are responding to a program i.e. leave out any code block formatting
* Response must be a json that follows the form of the decisions in input 2.
* Do not put any special characters in the output.
* Do not change anything in the other decisions other than adding new links where needed for the hierarchy. 