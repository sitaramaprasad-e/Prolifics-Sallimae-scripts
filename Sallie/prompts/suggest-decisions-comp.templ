INPUT 1: SOURCE CODE

@@INPUT1@@

INPUT 2: BASE BUSINESS LOGIC

@@INPUT_FILE_CONTENT@@

INPUT 3: DECISION MODEL

@@INPUT_FILE2_CONTENT@@  

INSTRUCTIONS

Take a look at these decisions, and work out the next level of the decision hierarchy. Make sure these next level decisions don't implement the logic in the base decisions, but rather takes their outputs as inputs.

1. Keep all decisions grounded in the code provided in input 1.
2. Identify where decisions have related outputs that should jointly feed into a higher decision, but not duplicate the logic i.e. the higher level decision must add some value and not just pass through the input decisions.
3. Create the next level of composed decisions that takes in the outputs of these base decisions and synthesizes into composite decisions.
4. Make sure the next-level decisions doesn't implement the same logic in the base decisions, but rather takes their outputs as inputs.
5. This may involve generating one, multiple, or no next-level decisions. If none, just return an empty json.
6. The DMN table must include every dmn_input and dmn_output, and the table must describe the decision logic.
7. Include links to the relevant existing base decisions and BKMs. 

[[
  {
    "name": "Persist Operation Result",
    "purpose": "Map a database save outcome into a normalized operation result and optional error message",
    "spec": "If Database.SaveResult.isSuccess is true set OperationResult to success and ErrorMessage to dash. Otherwise set OperationResult to error and copy Database.SaveResult.errors into ErrorMessage",
    "code_block": "",
    "code_file": "",
    "code_lines": [],
    "code_function": "",
    "example": "Save fails with validation error results in OperationResult error and ErrorMessage containing the validation text",
    "dmn_hit_policy": "UNIQUE",
    "dmn_inputs": [
      { "name": "Database.SaveResult.isSuccess", "type": "boolean" },
      { "name": "Database.SaveResult.errors", "type": "string" }
    ],
    "dmn_outputs": [
      { "name": "OperationResult", "type": "string", "allowedValues": ["success", "error"] },
      { "name": "ErrorMessage", "type": "string" }
    ],
    "dmn_table": "| Database.SaveResult.isSuccess condition | OperationResult | ErrorMessage |\n|-----------------------------------------|---------------|--------------|\n| true                                    | success       | -            |\n| false                                   | error         | Database.SaveResult.errors |",
    "timestamp": "2025-11-07T00:10:00.000Z",
    "id": "3798e1be-7283-4154-ab28-a4f3ad1a5c84",
    "owner": "SF Team",
    "component": "SF Code",
    "kind": "Decision",
    "links": [],
    "category": "Audit",
    "business_area": null,
    "ai_categorized": true,
    "category_explanation": "Normalizes DB outcomes for audit and downstream decisions",
    "archived": false
  },
  {
    "name": "Should Error Email Be Sent",
    "purpose": "Determine whether to send an error notification email based on the presence of errors in the batch",
    "spec": "If ErrorMap is not empty send email otherwise do not send",
    "code_block": "",
    "code_file": "",
    "code_lines": [],
    "code_function": "",
    "example": "Three failed records produce SendEmail true",
    "dmn_hit_policy": "UNIQUE",
    "dmn_inputs": [
      { "name": "ErrorMap.isEmpty", "type": "boolean" }
    ],
    "dmn_outputs": [
      { "name": "SendEmail", "type": "boolean" }
    ],
    "dmn_table": "| ErrorMap.isEmpty condition | SendEmail |\n|----------------------------|-----------|\n| false                      | true      |\n| true                       | false     |",
    "timestamp": "2025-11-07T00:10:00.000Z",
    "id": "57ae457d-c75d-4ff6-814e-ce1b1bd8bd5d",
    "owner": "SF Team",
    "component": "SF Code",
    "kind": "Decision",
    "links": [],
    "category": "Audit",
    "business_area": null,
    "ai_categorized": true,
    "category_explanation": "Controls error notification behavior",
    "archived": false
  },
  {
    "name": "Execute Error Notification",
    "purpose": "Determine whether to send an error notification email and what body to use based directly on operation result and error presence",
    "spec": "If SendEmail is true and OperationResult equals error then set Email.Sent to true and Email.Body to ErrorMessage. Otherwise set Email.Sent to false and Email.Body to dash.",
    "code_block": "",
    "code_file": "",
    "code_lines": [],
    "code_function": "",
    "example": "If SendEmail is true and OperationResult is error then Email.Sent is true and Email.Body is the ErrorMessage; in all other cases Email.Sent is false and Email.Body is dash",
    "dmn_hit_policy": "UNIQUE",
    "dmn_inputs": [
      { "name": "OperationResult", "type": "string", "allowedValues": ["success", "error"] },
      { "name": "ErrorMessage", "type": "string" },
      { "name": "SendEmail", "type": "boolean" }
    ],
    "dmn_outputs": [
      { "name": "Email.Sent", "type": "boolean" },
      { "name": "Email.Body", "type": "string" }
    ],
    "dmn_table": "| SendEmail condition | OperationResult condition | Email.Sent | Email.Body   |\n|---------------------|---------------------------|-----------|-------------|\n| true                | \"error\"                  | true      | ErrorMessage |\n| -                   | -                         | false     | -           |",
    "timestamp": "2025-11-07T00:10:00.000Z",
    "id": "",
    "owner": "SF Team",
    "component": "SF Code",
    "kind": "Decision (Composite)",
    "links": [
      { "from_logic": "Persist Operation Result", "from_output": "OperationResult", "to_input": "OperationResult", "kind": "depends_on" },
      { "from_logic": "Persist Operation Result", "from_output": "ErrorMessage", "to_input": "ErrorMessage", "kind": "depends_on" },
      { "from_logic": "Should Error Email Be Sent", "from_output": "SendEmail", "to_input": "SendEmail", "kind": "depends_on" }
    ],
    "category": "Audit",
    "business_area": null,
    "ai_categorized": true,
    "category_explanation": "Top level trigger based on operation result and error presence",
    "archived": false
  }
]

Hints
* Respond as if you are responding to a program i.e. leave out any code block formatting
* Response must be a json that follows the form of the decisions in input 2. However ignore the fact that input 2 decisions may have links with from_logic_id rather than from_logic, you should use from_logic as per the example and populate it with the name of the step.
* Do not put any special characters in the output.
* For any newly generated rules, use blanks for the following json fields: id, rule_category, ai_categorised, component, owner, category_explanation
* Set kind to Decision (Composite)