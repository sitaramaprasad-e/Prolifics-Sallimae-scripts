INPUT 1: SOURCE CODE

@@INPUT1@@

INPUT 2: LOGIC

@@INPUT_FILE_CONTENT@@

INPUT 3: SUGGESTED HIERARCHIES

@@INPUT_FILE2_CONTENT@@  

INSTRUCTIONS

Take a look at the suggested decision hierarchies (input 3) - which describes how to organise the existing logic in input 2, which are missing the middle layer that bind them together. I need you to create composite decisions that bind them together.

VERY IMPORTANT: Composite decisions must add some value and not just pass through the input decisions. There should be some actual logic contained in them. It is fine to join a base decision straight into the top-level if there is no meaningful logic to add in the middle.

You must return a json that includes:

1. A new set of one or more composite decisions in the middle layer, with links that go base (output/source) -> (input/target) composite (output/source) -> (input/target) top-level (note that links physically reside as a property on the target decisions).
1.1 Keep all decisions grounded in the code provided in input 1.
1.2 Pay careful attention to the direction of decision flows in your hierarchy, starting from base decision and BKMs at the bottom, flowing into composite decisions in the middle, flowing into top-level decisions on top.
1.3 Make sure the new middle-layer decisions doesn't implement the same logic in the existing base decisions, but rather takes outputs from the base layer and matching exactly to inputs. It is critical that the base outputs map to the middle composite inputs exactly, so formulate the inputs of the middle-layer to be an exact match for the output of the base layer.
1.4 Make sure the new middle-layer decisions doesn't implement the same logic as the existing top-level decisions, but provides outputs that match their inputs. It is critical that the middle ouputs map to the top-level inputs exactly, so formulate the outputs of the middle-layer to be an exact match for the inputs of the top layer.
1.5 Use blanks for the following json fields: id, category, ai_categorised, component, owner, category_explanation. Also set the kind to Decision (Composite) for these new decisions.
1.6 It is very important that you set id to "" for a new composite decision, do not try and come up with some value.
1.7 This may involve generating one, multiple, or no middle-layer composite decisions. If none, just return an empty json.
1.8 Attempt to ensure that the there are composite decisions that cover all of the base decisions, except where that base decision should not part of the suggested hierarchy in input 3.
1.9 Ensure that the DMN table and inputs/outputs are consistent with the purpose/spec/example of the new composite decision, and cover all of the behaviour implied by the base decisions that feed into it and the top-level decisions that it feeds into.
1.10 The DMN table must include every dmn_input and dmn_output, and the table must describe the decision logic.

2. Top-level decisions, with new links added to their links property that show the new links coming from the composite decisions. Do NOT change the name of the top-level decision that is set in the suggested hierarchy in input 3.
2.1 Where you see a top-level decision with an empty rule_id (i.e. "") it will need to be created. To indicate that you need to include it in the output with an empty rule_id i.e. "", setting its kind to Decision (Top-Level) and giving it a suitable purpose, spec, example, and inputs and outputs, and incoming links.

3. Any other existing decisions for which you need to add missing links to properly reflect the suggested hierarchy in input 3 (with new links added to their links property).

Be careful when creating links, they need to adhere to these rules:

- Decisions should flow up to the top-level. Links should go from base decision/BKMs, to composite decisions, to top-level decisions (but links physically reside in the links property on the target decision)
- Only top-level and composite decisions should have links properties (containing the links coming into them). 
- DO NOT create loops where a decision links to a another decision that then links back to the original.
- ONLY create the link on the decision that is the target (it is implied on the source).
- Ensure that there are no decisions at any level that have a top-level decision in its links property (this is because top-level links can't be a source).
- Populate the link_explanation with your reasoning on why you have linked those inputs/outputs. Explain 1) how good the match is 2) the detailed reason behind your decision to create this link that will stand up in a court of law.

Reponse must be in this json structure:

[
  {
    "name": "Persist Operation Result",
    "purpose": "Map a database save outcome into a normalized operation result and optional error message",
    "spec": "If Database.SaveResult.isSuccess is true set OperationResult to success and ErrorMessage to dash. Otherwise set OperationResult to error and copy Database.SaveResult.errors into ErrorMessage",
    "dmn_inputs": [
      { "name": "Database.SaveResult.isSuccess", "type": "boolean" },
      { "name": "Database.SaveResult.errors", "type": "string" }
    ],
    "dmn_outputs": [
      { "name": "OperationResult", "type": "string", "allowedValues": ["success", "error"] },
      { "name": "ErrorMessage", "type": "string" }
    ],
    "links": []
  },
  {
    "name": "Should Error Email Be Sent",
    "purpose": "Determine whether to send an error notification email based on the presence of errors in the batch",
    "dmn_inputs": [
      { "name": "ErrorMap.isEmpty", "type": "boolean" }
    ],
    "dmn_outputs": [
      { "name": "SendEmail", "type": "boolean" }
    ],
    "links": []
  },
  {
    "name": "Compose Error Notification Outcome",
    "purpose": "Compose whether to notify and the message body by combining operation result and send email decision",
    "dmn_inputs": [
      { "name": "OperationResult", "type": "string" },
      { "name": "ErrorMessage", "type": "string" },
      { "name": "SendEmail", "type": "boolean" }
    ],
    "dmn_outputs": [
      { "name": "Notification.ShouldSend", "type": "boolean" },
      { "name": "Notification.Body", "type": "string" }
    ],
    "links": [
      {
        "from_logic": "Persist Operation Result",
        "from_output": "OperationResult",
        "to_input": "OperationResult",
        "kind": "depends_on",
        "link_explanation": "The output OperationResult exactly matches the input OperationResult (same name and type), so this link is a direct structural match."
      },
      {
        "from_logic": "Persist Operation Result",
        "from_output": "ErrorMessage",
        "to_input": "ErrorMessage",
        "kind": "depends_on",
        "link_explanation": "The output ErrorMessage matches the input ErrorMessage exactly, so the AI established this link based on direct alignment."
      },
      {
        "from_logic": "Should Error Email Be Sent",
        "from_output": "SendEmail",
        "to_input": "SendEmail",
        "kind": "depends_on",
        "link_explanation": "SendEmail is produced and consumed with identical name and type, making this a straightforward field-aligned link."
      },
      {
        "from_logic": "Persist Operation Result",
        "from_output": "OperationResult",
        "to_input": "SendEmail",
        "kind": "depends_on",
        "link_explanation": "The names and types do not match (string vs boolean), but the AI inferred a semantic relationship because SendEmail is evaluated only when OperationResult is \"error\". The pipeline identified this conditional dependency in the rule specifications."
      }
    ]
  },
  {
    "name": "Execute Error Notification",
    "purpose": "Trigger the actual email send based on composed notification outcome",
    "dmn_inputs": [
      { "name": "Notification.ShouldSend", "type": "boolean" },
      { "name": "Notification.Body", "type": "string" }
    ],
    "dmn_outputs": [
      { "name": "Email.Sent", "type": "boolean" }
    ],
    "links": [
      {
        "from_logic": "Compose Error Notification Outcome",
        "from_output": "Notification.ShouldSend",
        "to_input": "Notification.ShouldSend",
        "kind": "depends_on",
        "link_explanation": "The hierarchical name and type Notification.ShouldSend match exactly, so this link is structurally aligned."
      },
      {
        "from_logic": "Compose Error Notification Outcome",
        "from_output": "Notification.Body",
        "to_input": "Notification.Body",
        "kind": "depends_on",
        "link_explanation": "Output and input fields both use Notification.Body with matching string types, so this link is based on direct alignment."
      },
      {
        "from_logic": "Compose Error Notification Outcome",
        "from_output": "Notification.ShouldSend",
        "to_input": "Email.Sent",
        "kind": "depends_on",
        "link_explanation": "The names do not match, but the AI linked them because Email.Sent is logically determined by Notification.ShouldSend. The specification describes Email.Sent as a direct action triggered by ShouldSend, indicating a control-flow dependency."
      }
    ]
  }
]

Hints
* Respond as if you are responding to a program i.e. leave out any code block formatting
* Response must be a json that follows the form of the decisions in input 2. However ignore the fact that input 2 decisions may have links with from_logic_id rather than from_logic, you should use from_logic as per the example and populate it with the name of the step.
* Do not put any special characters in the output.
* For any newly generated rules, use blanks for the following json fields: id, category, ai_categorised, component, owner, category_explanation
* Do not change anything in the other decisions other than adding new links where needed for the hierarchy. 